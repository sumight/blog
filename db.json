{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/modernist/source/js/scale.fix.js","path":"js/scale.fix.js","modified":1},{"_id":"themes/modernist/source/js/moment.min.js","path":"js/moment.min.js","modified":1},{"_id":"themes/modernist/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/modernist/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/modernist/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/modernist/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/modernist/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/modernist/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/modernist/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/modernist/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/modernist/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/modernist/source/css/images/checker.png","path":"css/images/checker.png","modified":1},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/modernist/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1}],"Cache":[{"_id":"source/_drafts/xiaoming.md","shasum":"8b5247cd219b349d61e273cb17a6cad6ceca47ec","modified":1447810290000},{"_id":"source/_posts/arrow-left.md","shasum":"56a3358b3c598b402f807c18eb10f82b2dea86ce","modified":1448282698000},{"_id":"source/_posts/b.md","shasum":"3e39537f732c6c0dcc5d1a35490e24dd8ccdc2ba","modified":1449105909000},{"_id":"source/_posts/a.md","shasum":"1e21a3abec7bb5a945632f404a875792bee0501e","modified":1448289915000},{"_id":"source/_posts/html代码规范.md","shasum":"1c35691f239cd05f5b3d84af96f26414d03b56b0","modified":1449199531000},{"_id":"source/_posts/c.md","shasum":"e2efb64237f74e95846a82e0f56845e6e304d064","modified":1449105931000},{"_id":"source/_posts/javascript代码规范.md","shasum":"44ea70267b0f60308e6ba909b46d06d150dea79b","modified":1449153578000},{"_id":"source/_posts/html注释规范.md","shasum":"1680a14d7132c40bb1dc41acc6fe3d32ac8b1107","modified":1449211812000},{"_id":"source/_posts/javascript注释规范.md","shasum":"b20f8fad2749b24c682a48768a8b8a0b60519e53","modified":1449153502000},{"_id":"source/_posts/less图标讲解.md","shasum":"dcce7763343d3d2e583dacc75ab1ccd5ec101bc4","modified":1448280144000},{"_id":"source/_posts/加号按钮.md","shasum":"938562aa91c2c92f9b1503d7a1936b4c0e7444fc","modified":1448281699000},{"_id":"source/_posts/文档系统使用手册.md","shasum":"213ff457576ead2c1257a4dd019d02012ae1da3d","modified":1449462959000},{"_id":"source/_posts/文档的发布.md","shasum":"d75dcafc5f76e686d48b7939fa607a64aa475c58","modified":1449450998000},{"_id":"source/first/index.md","shasum":"aac622cd9d14a05c5bdf2b772d57153c33f36ca5","modified":1448181122000},{"_id":"themes/modernist/_config.yml","shasum":"93a3456f3d47ade94cd6521d77091f33c1c8f3e0","modified":1449459702000},{"_id":"themes/modernist/LICENSE","shasum":"391dd84c2091363936603d63cc71ba1628a13c86","modified":1449220311000},{"_id":"themes/modernist/languages/default.yml","shasum":"bbde9b1c157db32eacfd0eb267a9949d09d592e9","modified":1449220311000},{"_id":"themes/modernist/README.md","shasum":"cf3816c676f356801a90a455db5063c99c165e7a","modified":1449220311000},{"_id":"themes/modernist/languages/zh-CN.yml","shasum":"6143ffa6867115ad939881c18d0a0ff1d4e4cb39","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/archive-post.ejs","shasum":"1ff2121a50db007e9f4978134c0d78969505b557","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/after-footer.ejs","shasum":"01ec99bf45cf88b14111987c849b8974f90f9b85","modified":1449221291000},{"_id":"themes/modernist/layout/_partial/archive.ejs","shasum":"6a5cdcefcafafaf6a09251b166658c1063bdc627","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/google-analytics.ejs","shasum":"98a27ce8a3d3e4596787b8661efc2a59b182c13a","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/footer.ejs","shasum":"5c8178763a67fd0b6a44a2b5faf51bed183fa681","modified":1449223692000},{"_id":"themes/modernist/layout/_partial/comment.ejs","shasum":"c318124752f1919ff15c1bde0816f31ea19cee2b","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/article.ejs","shasum":"d5a9bff2b555d2f3ff358bfb13d32fc9bca7f0aa","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/head.ejs","shasum":"68964681d0a5360b88a6aa123e7f30312d1524dd","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/post/category.ejs","shasum":"53af0ec48fbf2c41f4bd7044a7f1a0d8419a9361","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/header.ejs","shasum":"db6bb78a9c28f49fa1041e43edd4a119b40446c1","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/pagination.ejs","shasum":"3b19c3790a8e5abc2563bd7874cb32539f9ef40f","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/post/date.ejs","shasum":"2e103ef24430a40f95c8a220ec3aee1bb0f8c213","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/post/tag.ejs","shasum":"1a9dc8f8781a7def8b07445270ef323011b3ce46","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/post/gallery.ejs","shasum":"bd41f384ab7dad35516ce600dfebcd77c308bab9","modified":1449220311000},{"_id":"themes/modernist/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1449220311000},{"_id":"themes/modernist/layout/_partial/post/title.ejs","shasum":"cf6347f1a36f851ae7d76b712c9a152041dd428e","modified":1449220311000},{"_id":"themes/modernist/layout/layout.ejs","shasum":"e9b41be33d7bd8ac08db1b42e6f9a101cbd363b6","modified":1449220311000},{"_id":"themes/modernist/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1449220311000},{"_id":"themes/modernist/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1449220311000},{"_id":"themes/modernist/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1449220311000},{"_id":"themes/modernist/source/css/_base/layout.styl","shasum":"e155c2ca1a8fc79523b30db2ea52b1eb573f06a7","modified":1449220311000},{"_id":"themes/modernist/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1449220311000},{"_id":"themes/modernist/source/css/_partial/archive.styl","shasum":"d2bd94e52f1f12caed77db890a039c7bfe7e0c36","modified":1449220311000},{"_id":"themes/modernist/source/css/_partial/comment.styl","shasum":"b8328cdce54bd643b0f0f4d757bffeaaa38c7a56","modified":1449220311000},{"_id":"themes/modernist/source/css/_base/variable.styl","shasum":"0b925a57d93ed930eb5c6b10fe61134cf40e291c","modified":1449220311000},{"_id":"themes/modernist/source/css/_partial/article.styl","shasum":"7d802117f1bd87662b021b1c454f6451ac9a7104","modified":1449462897000},{"_id":"themes/modernist/source/css/_partial/footer.styl","shasum":"959ddf16adacf7c19b0918adc65c592fc45b44e3","modified":1449220311000},{"_id":"themes/modernist/source/css/_partial/header.styl","shasum":"d18e71fb3120131cd8957db380c7af316a89d033","modified":1449220311000},{"_id":"themes/modernist/source/css/_partial/index.styl","shasum":"5df2ef5d8f6ff83d70a50cc9fa58ed891adc4709","modified":1449220311000},{"_id":"themes/modernist/source/css/_partial/syntax.styl","shasum":"421d3f5634a436a14717f99cdb1f5d39f2634d87","modified":1449462771000},{"_id":"themes/modernist/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1449220311000},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1449220311000},{"_id":"themes/modernist/source/css/images/checker.png","shasum":"108be8f4c3cfb91ef35050a1120659d946d7ebbc","modified":1449220311000},{"_id":"themes/modernist/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1449220311000},{"_id":"themes/modernist/source/fancybox/fancybox_loading.gif","shasum":"48673ea547f521de42a1a2057df6939cafda7ae5","modified":1449220311000},{"_id":"themes/modernist/source/css/style.styl","shasum":"641c90d96997e5f77faf920e37a3ba42518bdc28","modified":1449220311000},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1449220311000},{"_id":"themes/modernist/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1449220311000},{"_id":"themes/modernist/source/fancybox/jquery.fancybox.css","shasum":"98644f55b533a25495961ac6fd411ca27807d54d","modified":1449220311000},{"_id":"themes/modernist/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1449220311000},{"_id":"themes/modernist/source/fancybox/jquery.fancybox.pack.js","shasum":"2629dcc9d237f1244c02de196733830a5723cb90","modified":1449220311000},{"_id":"themes/modernist/source/js/gallery.js","shasum":"e5c7dd04c8992e5c10fc53dc57e57c3fbe2b66c7","modified":1449220311000},{"_id":"themes/modernist/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1449220311000},{"_id":"themes/modernist/source/js/moment.min.js","shasum":"764c7d63fed0b42fbf576c816470d81cb937ecd3","modified":1449220311000},{"_id":"themes/modernist/source/js/scale.fix.js","shasum":"bbf62458c63fca2535965f9dfaacfbc6bc697e03","modified":1449220311000},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1449220311000},{"_id":"themes/modernist/source/css/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1449220311000}],"Category":[{"name":"使用手册","_id":"cihvgpwua0003r1bhliwwxb0t"},{"name":"less图标库","_id":"cihvgpwuh0007r1bhaakhtw0p"},{"name":"前端规范","_id":"cihvgpwum000cr1bh3sek34kl"},{"name":"前端代码规范","parent":"cihvgpwum000cr1bh3sek34kl","_id":"cihvgpwum000dr1bh3eraomao"},{"name":"other","_id":"cihvgpwuz000qr1bhi551scay"},{"name":"theother","parent":"cihvgpwuz000qr1bhi551scay","_id":"cihvgpwv3000vr1bh1vmpbpod"}],"Data":[],"Page":[{"title":"first","date":"2015-11-20T09:31:14.000Z","_content":"## this is second\n\n### asdljads\n### alsfjalsfj\n|asdf|asdfasd|\n|:----:|:-----:|\n|asdfasd|asdfsad|\n\n\n<div class=\"box\">bcs</div>\n\n<style>\n    .box{\n        background: red;\n    }\n</style>\n\n<script type=\"text/javascript\">\n    console.log('abc');\n</script>\n\n## alsdjf\n## asdlfja\n## adsljfa\n## aldsfja","source":"first/index.md","raw":"title: first\ndate: 2015-11-20 17:31:14\n---\n## this is second\n\n### asdljads\n### alsfjalsfj\n|asdf|asdfasd|\n|:----:|:-----:|\n|asdfasd|asdfsad|\n\n\n<div class=\"box\">bcs</div>\n\n<style>\n    .box{\n        background: red;\n    }\n</style>\n\n<script type=\"text/javascript\">\n    console.log('abc');\n</script>\n\n## alsdjf\n## asdlfja\n## adsljfa\n## aldsfja","updated":"2015-11-22T08:32:02.000Z","path":"first/index.html","comments":1,"layout":"page","_id":"cihvgpwu60001r1bhygh28vvt"}],"Post":[{"title":"xiaoming","_content":"","source":"_drafts/xiaoming.md","raw":"title: xiaoming\ntags:\n---\n","slug":"xiaoming","published":0,"date":"2015-12-07T02:47:28.000Z","updated":"2015-11-18T01:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwts0000r1bhzycens6c"},{"title":"文档系统使用手册","date":"2015-12-07T02:55:53.000Z","_content":"\n## 环境准备\n\n### github 环境\n\n配置ssh,具体步骤见[教程](https://help.github.com/articles/generating-ssh-keys)\n\n### hexo 环境\n\n```shell\n$ npm install hexo -g\n```\n\n### 克隆源代码\n\n```shell\n$ git clone git@github.com:ycode-front/document.git\n```\n\n### 安装包\n\n在源代码目录下\n\n```shell\n$ npm install\n```\n\n## 发布文章\n\n### 第一步 拉取最新代码\n\n在源代码目录下\n\n```shell\n$ git pull origin master\n```\n\n### 第二步 创建一个文档\n\n在源代码目录下\n\n```shell\n$ hexo new post [文档的名称]\n```\n\n### 第三步 填写对应的目录\n\n1. 用编辑器打开源代码目录\n2. 打开 ``souce/_posts/[文档的名称]``文件\n3. 修改 categories \n\n### 第四步 写文档\n\n1. 用编辑器打开源代码目录\n2. 打开 ``souce/_posts/[文档的名称]``文件\n3. 用 markdown 格式写文档\n\n### 第五步 推送代码\n\n文档填写完成之后，请提交代码。否则别人在添加文档发布之后你的文档就丢失了。\n\n### 第六步 发布文档\n\n在源代码目录下\n\n```shell\n$ hexo generate #生成发布代码\n$ hexo deploy #发布到服务器\n```\n\n### 本地预览站点\n\n在源代码目录下\n\n```shell\n$ hexo server #开启本地服务器预览\n```\n\n## 文档系统原理\n这个文档系统是基于 [hexo](https://hexo.io) 这个静态站点发布工具的。所以了解一下基本的hexo命令对于文档系统的使用大有帮助。\n\n文档系统分为__源代码__和__发布代码__两部分，类似前端构建中的开发目录和发布目录。\n\n__发布代码__是直接可以打开的页面。这部分代码被部署到[github pages](https://pages.github.com)上。[github pages](https://pages.github.com) 可以理解为一个静态服务器，将__发布代码__发布到pages的方法非常简单，就是新建一个特殊的github仓库，然后将代码上传到这个仓库，就可以使用指定的域名进行访问了。在这个文档系统中，这个仓库是[git@github.com:ycode-front/ycode-front.github.io.git](git@github.com:ycode-front/ycode-front.github.io.git)，而域名是[http://ycode-front.github.io](http://ycode-front.github.io).更多的信息可以查看[github pages](https://pages.github.com)。实际上发布是自动化，hexo在发布的时候，会自动把发布代码上传到指定的仓库，所以我们不用关注这个发布仓库。\n\n__源代码__也被放在github上，仓库是[git@github.com:ycode-front/document.git](git@github.com:ycode-front/document.git),将它称为源代码仓库。我们新建文档，修改文档都是在源代码中进行的.在修改之前需要拉去源代码，在修改之后需要推送源代码，因为文档的维护不止一个人。其实就和我们开发项目一样，最后进行发布。","source":"_posts/文档系统使用手册.md","raw":"title: 文档系统使用手册\ndate: 2015-12-07 10:55:53\ncategories:\n- 使用手册\n---\n\n## 环境准备\n\n### github 环境\n\n配置ssh,具体步骤见[教程](https://help.github.com/articles/generating-ssh-keys)\n\n### hexo 环境\n\n```shell\n$ npm install hexo -g\n```\n\n### 克隆源代码\n\n```shell\n$ git clone git@github.com:ycode-front/document.git\n```\n\n### 安装包\n\n在源代码目录下\n\n```shell\n$ npm install\n```\n\n## 发布文章\n\n### 第一步 拉取最新代码\n\n在源代码目录下\n\n```shell\n$ git pull origin master\n```\n\n### 第二步 创建一个文档\n\n在源代码目录下\n\n```shell\n$ hexo new post [文档的名称]\n```\n\n### 第三步 填写对应的目录\n\n1. 用编辑器打开源代码目录\n2. 打开 ``souce/_posts/[文档的名称]``文件\n3. 修改 categories \n\n### 第四步 写文档\n\n1. 用编辑器打开源代码目录\n2. 打开 ``souce/_posts/[文档的名称]``文件\n3. 用 markdown 格式写文档\n\n### 第五步 推送代码\n\n文档填写完成之后，请提交代码。否则别人在添加文档发布之后你的文档就丢失了。\n\n### 第六步 发布文档\n\n在源代码目录下\n\n```shell\n$ hexo generate #生成发布代码\n$ hexo deploy #发布到服务器\n```\n\n### 本地预览站点\n\n在源代码目录下\n\n```shell\n$ hexo server #开启本地服务器预览\n```\n\n## 文档系统原理\n这个文档系统是基于 [hexo](https://hexo.io) 这个静态站点发布工具的。所以了解一下基本的hexo命令对于文档系统的使用大有帮助。\n\n文档系统分为__源代码__和__发布代码__两部分，类似前端构建中的开发目录和发布目录。\n\n__发布代码__是直接可以打开的页面。这部分代码被部署到[github pages](https://pages.github.com)上。[github pages](https://pages.github.com) 可以理解为一个静态服务器，将__发布代码__发布到pages的方法非常简单，就是新建一个特殊的github仓库，然后将代码上传到这个仓库，就可以使用指定的域名进行访问了。在这个文档系统中，这个仓库是[git@github.com:ycode-front/ycode-front.github.io.git](git@github.com:ycode-front/ycode-front.github.io.git)，而域名是[http://ycode-front.github.io](http://ycode-front.github.io).更多的信息可以查看[github pages](https://pages.github.com)。实际上发布是自动化，hexo在发布的时候，会自动把发布代码上传到指定的仓库，所以我们不用关注这个发布仓库。\n\n__源代码__也被放在github上，仓库是[git@github.com:ycode-front/document.git](git@github.com:ycode-front/document.git),将它称为源代码仓库。我们新建文档，修改文档都是在源代码中进行的.在修改之前需要拉去源代码，在修改之后需要推送源代码，因为文档的维护不止一个人。其实就和我们开发项目一样，最后进行发布。","slug":"文档系统使用手册","published":1,"updated":"2015-12-07T04:35:59.000Z","_id":"cihvgpwu80002r1bh8qj8rft7","comments":1,"layout":"post","photos":[],"link":""},{"title":"文档的发布","date":"2015-12-07T01:16:38.000Z","_content":"","source":"_posts/文档的发布.md","raw":"title: 文档的发布\ndate: 2015-12-07 09:16:38\ncategories:\n---\n","slug":"文档的发布","published":1,"updated":"2015-12-07T01:16:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwue0005r1bhoaworn3t"},{"title":"add-btn","date":"2015-11-23T09:34:17.000Z","_content":"\n按钮加号\n\n```less\n.ico-add(@size, @bg, @inner)\n```\n\n\n## 参数\n\n| 参数名 | 含义 |\n|:-----:|:----:|\n| @size |按钮的尺寸，为外层圆形的尺寸|\n| @bg |北京颜色|\n| @inner |内部十字的颜色|\n\n\n## demo\n\n### 代码\n\n```less\n.add-btn {\n    margin-top: -15px;\n    top: 50%;\n    right: 45px;\n    .ico-add(30px, gray, white);\n    position: absolute;\n}\n```\n\n### 效果\n\n<i class=\"demo\"></i>\n<style type=\"text/css\">\n    .demo {\n      margin: 0.83333333rem;\n      top: 50%;\n      display: inline-block;\n      border-radius: 50%;\n      width: 1.66666667rem;\n      height: 1.66666667rem;\n      background-color: #d7d7d7;\n      position: relative;\n    }\n    .demo:after {\n      content: '';\n      display: block;\n      width: 0.17857143rem;\n      height: 0.95238095rem;\n      margin-top: -0.47619048rem;\n      margin-left: -0.08928571rem;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      background-color: white;\n    }\n    .demo:before {\n      content: '';\n      display: block;\n      width: 0.95238095rem;\n      height: 0.17857143rem;\n      margin-top: -0.08928571rem;\n      margin-left: -0.47619048rem;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      background-color: white;\n    }\n</style>\n\n\n## 源代码\n```less\n.ico-add(@size, @bg, @inner) {\n    display: inline-block;\n    border-radius: 50%;\n    width: @size;\n    height: @size;\n    @barW: @size*(3/28);\n    @barH: @size*(16/28);\n    position: relative;\n    background-color: @bg;\n    &:after {\n        content: '';\n        display: block;\n        width: @barW;\n        height: @barH;\n        margin-top: -@barH/2;\n        margin-left: -@barW/2;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        background-color: @inner;\n    }\n    &:before {\n        content: '';\n        display: block;\n        width: @barH;\n        height: @barW;\n        margin-top: -@barW/2;\n        margin-left: -@barH/2;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        background-color: @inner;\n    }\n}\n```","source":"_posts/加号按钮.md","raw":"title: add-btn\ndate: 2015-11-23 17:34:17\ncategories:\n- less图标库\n---\n\n按钮加号\n\n```less\n.ico-add(@size, @bg, @inner)\n```\n\n\n## 参数\n\n| 参数名 | 含义 |\n|:-----:|:----:|\n| @size |按钮的尺寸，为外层圆形的尺寸|\n| @bg |北京颜色|\n| @inner |内部十字的颜色|\n\n\n## demo\n\n### 代码\n\n```less\n.add-btn {\n    margin-top: -15px;\n    top: 50%;\n    right: 45px;\n    .ico-add(30px, gray, white);\n    position: absolute;\n}\n```\n\n### 效果\n\n<i class=\"demo\"></i>\n<style type=\"text/css\">\n    .demo {\n      margin: 0.83333333rem;\n      top: 50%;\n      display: inline-block;\n      border-radius: 50%;\n      width: 1.66666667rem;\n      height: 1.66666667rem;\n      background-color: #d7d7d7;\n      position: relative;\n    }\n    .demo:after {\n      content: '';\n      display: block;\n      width: 0.17857143rem;\n      height: 0.95238095rem;\n      margin-top: -0.47619048rem;\n      margin-left: -0.08928571rem;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      background-color: white;\n    }\n    .demo:before {\n      content: '';\n      display: block;\n      width: 0.95238095rem;\n      height: 0.17857143rem;\n      margin-top: -0.08928571rem;\n      margin-left: -0.47619048rem;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      background-color: white;\n    }\n</style>\n\n\n## 源代码\n```less\n.ico-add(@size, @bg, @inner) {\n    display: inline-block;\n    border-radius: 50%;\n    width: @size;\n    height: @size;\n    @barW: @size*(3/28);\n    @barH: @size*(16/28);\n    position: relative;\n    background-color: @bg;\n    &:after {\n        content: '';\n        display: block;\n        width: @barW;\n        height: @barH;\n        margin-top: -@barH/2;\n        margin-left: -@barW/2;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        background-color: @inner;\n    }\n    &:before {\n        content: '';\n        display: block;\n        width: @barH;\n        height: @barW;\n        margin-top: -@barW/2;\n        margin-left: -@barH/2;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        background-color: @inner;\n    }\n}\n```","slug":"加号按钮","published":1,"updated":"2015-11-23T12:28:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwug0006r1bhlrehtk0y"},{"title":"简介","date":"2015-11-23T11:59:39.000Z","_content":"\nless图标库是 使用less函数写的一些简单的图标。可以传入参数控制图标的颜色，大小等属性。\n","source":"_posts/less图标讲解.md","raw":"title: 简介\ndate: 2015-11-23 19:59:39\ncategories:\n- less图标库\n---\n\nless图标库是 使用less函数写的一些简单的图标。可以传入参数控制图标的颜色，大小等属性。\n","slug":"less图标讲解","published":1,"updated":"2015-11-23T12:02:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwui0009r1bhckyfki2m"},{"title":"javascript注释规范","date":"2015-12-03T13:26:45.000Z","_content":"\n## 模块的注释\n\n在模块的注释中还可以添加更多的信息，比如日期等等。\n\n在模块的描述可以不止一行，根据需要填写，写完描述空一行。\n\n```javascript\n\n/**\n * [description]\n * \n * @module [modulename]\n * @author sumight\n */\n\n```\n\n## 函数注释\n\n如果函数没有参数，也没有返回值，那么注释可以只有描述信息\n\n例子紧跟在描述的下面，最后空一行。\n\n将例子和描述放在一起是因为描述和例子都可能很长，而参数和返回值等重要信息需要和函数实体紧靠在一起。\n\n```javascript\n\n/**\n * [fun description]\n * Example:\n *      var name = fun('小明'');\n *      var hello = name + ' 你好';\n * \n * @param  {[type]} name [description]\n * @return {[type]}      [description]\n */\nfunction fun(name){\n\n    return name;\n\n}\n\n```\n\n## 关键变量注释\n\n```javascript\n\n/**\n * [cfg description]\n * \n * @type {Object}\n */\nvar cfg = {};\n\n```\n\n## 语句注释\n\n```javascript\n\n// 计算 a 和 b 的和\nx = a + b;\n\n```\n\n## TODO注释\n\nTODO 用来标记下次需要做的工作，相当于一个标签，在一段代码没有完成的时候可以使用doto来标记未完成的代码位置\n\n```javascript\n\n// TODO 计算多个数的和\nx = a + b + ;\n\n```\n","source":"_posts/javascript注释规范.md","raw":"title: javascript注释规范\ndate: 2015-12-03 21:26:45\ncategories:\n- 前端规范\n- 前端代码规范\n---\n\n## 模块的注释\n\n在模块的注释中还可以添加更多的信息，比如日期等等。\n\n在模块的描述可以不止一行，根据需要填写，写完描述空一行。\n\n```javascript\n\n/**\n * [description]\n * \n * @module [modulename]\n * @author sumight\n */\n\n```\n\n## 函数注释\n\n如果函数没有参数，也没有返回值，那么注释可以只有描述信息\n\n例子紧跟在描述的下面，最后空一行。\n\n将例子和描述放在一起是因为描述和例子都可能很长，而参数和返回值等重要信息需要和函数实体紧靠在一起。\n\n```javascript\n\n/**\n * [fun description]\n * Example:\n *      var name = fun('小明'');\n *      var hello = name + ' 你好';\n * \n * @param  {[type]} name [description]\n * @return {[type]}      [description]\n */\nfunction fun(name){\n\n    return name;\n\n}\n\n```\n\n## 关键变量注释\n\n```javascript\n\n/**\n * [cfg description]\n * \n * @type {Object}\n */\nvar cfg = {};\n\n```\n\n## 语句注释\n\n```javascript\n\n// 计算 a 和 b 的和\nx = a + b;\n\n```\n\n## TODO注释\n\nTODO 用来标记下次需要做的工作，相当于一个标签，在一段代码没有完成的时候可以使用doto来标记未完成的代码位置\n\n```javascript\n\n// TODO 计算多个数的和\nx = a + b + ;\n\n```\n","slug":"javascript注释规范","published":1,"updated":"2015-12-03T14:38:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwul000br1bhhglu502q"},{"title":"javascript 代码规范","date":"2015-11-18T01:26:36.000Z","_content":"\n\n## 使用严格模式\n\n使用严格模式会对代码进行更严格的检测，避免一些意想不到错误，同时也是为将来的js版本做兼容。严格模式的规则可以参考[Javascript 严格模式详解](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html).\n\n```javascript\n(function($){\n    'use strict';\n\n    //do some thing\n\n}(jQuery))\n```\n\n注意：前外不要在全局使用严格模式，这样会对第三方插件产生影响，产生错误\n\n## 变量的声明\n\n变量的声明请提前到模块或者函数的开头，并且使用下面的格式。\n\n```javascript\nfunction fun(){\n    var a = 1,\n        b = 3,\n        c = 5;\n\n    // do some thing\n}\n```\n\n## 判断相等\n\n判断相等的时候，请使用严格相等符号 ``===`` 而不是 ``==``\n\n## 分号的使用\n\n在每一个表达式结束的时候加上分号\n并不是所有的语句都是表达式，下面举例说明\n\n```javascript\n\nfunction fun(){\n\n} //函数声明，不是表达式，无需分号\n\n\nvar getName = function(){\n\n}; //函数表达式，请加上分号\n\n\nif(true){\n\n} //这也不是表达式，当然不用加分号\n\n```\n\n## 循环\n\n### for-in循环\n\n在使用for-in循环的时候，请注意两点\n\n1. 不要使用for-in循环遍历数组元素\n2. 在使用for-in遍历对象的时候，请判断属性是否来自继承\n\n```javascript\n\nvar obj = {x:1,y:2,z:3}\n\nfor(var e in obj){\n    if(!obj.hasOwnProperty(e)) continue;\n\n    // do something to e\n\n}\n\n```\n\n### 数组的遍历\n\n如果要对数组进行遍历，可以使用传统的 for 循环，或者es5提供的数组遍历方法。\n\n```javascript\n\n// 传统的 for 方法\n\nvar arr = [1,2,3,4,5];\n\nfor(var i = 0, e = arr[i]; i < arr.length; i++){\n\n    // do something to e\n\n}\n\n```\n\nes5的数组操作方法\n\n- forEach\n- every\n- map\n- filter\n- some\n- reduce\n\n使用这些方法的时候请注意[兼容性](http://caniuse.com/#search=forEach)\n\n## 引号的使用\n\n在javascript中使用单引号，而在html标签中使用双引号\n\n```javascript\nvar str = 'this is string';\n```\n\n```html\n<div class=\"footer\"> </div>\n```\n\n## 模块化\n\n目前使用的模块化的方式是两种，一种是模板模式，一种是 browserify.\n\n既然做了模块化，需要做到一个文件放一个模块。\n\n### 模板模式\n\n使用一个立即执行函数对每一段代码进行封装，避免变量暴露在全局\n\n```javascript\n\n/**\n * [description]\n * \n * @module [modulename]\n * @author sumight\n */\n\n(function($){\n    'use strict';\n\n    var Main = window.Main = {};\n        \n    /**\n     * 模块的默认配置\n     */\n    Main.defaultCfg = {\n\n    };\n\n    /**\n     * 模块初始化\n     * \n     * @param  {Object} cfg 用户配置\n     */\n    Main.init = function(cfg){\n        var self = this,\n            cfg = this._cfg = $.extend({}, self.defaultCfg, cfg);\n\n        // do something\n        \n    };\n\n    /**\n     * 初始化事件\n     */\n    Main.initEvent = function(){\n\n    };\n}(jQuery));\n\n```\n\n### browserify\n\n采用nodejs的模块化方式写前端代码。\n\n```javascript\n\n/**\n * [description]\n * \n * @module [modulename]\n * @author sumight\n */\n\n'use strict';\n\n/**\n * 模块依赖\n */\nvar $ = require(\"jQuery\"),\n    util = require(\"util\");\n\n/**\n * 导出模块\n * 如果模块需要暴露给html\n * 就这样写\n *  var Main = window.Main = exports;\n */\nvar Main = exports;\n\n/**\n * 模块的默认配置\n */\nMain.defaultCfg = {\n\n}\n\n/**\n * 模块初始化\n * \n * @param  {Object} cfg 用户配置\n */\nMain.init = function(cfg){\n    var self = this,\n        cfg = this._cfg = $.extend({}, self.defaultCfg, cfg);\n\n    // do something\n    \n};\n\n/**\n * 初始化事件\n */\nMain.initEvent = function(){\n\n};\n\n\n```\n","source":"_posts/javascript代码规范.md","raw":"title: javascript 代码规范\ndate: 2015-11-18 09:26:36\ntags:\ncategories:\n- 前端规范\n- 前端代码规范\n---\n\n\n## 使用严格模式\n\n使用严格模式会对代码进行更严格的检测，避免一些意想不到错误，同时也是为将来的js版本做兼容。严格模式的规则可以参考[Javascript 严格模式详解](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html).\n\n```javascript\n(function($){\n    'use strict';\n\n    //do some thing\n\n}(jQuery))\n```\n\n注意：前外不要在全局使用严格模式，这样会对第三方插件产生影响，产生错误\n\n## 变量的声明\n\n变量的声明请提前到模块或者函数的开头，并且使用下面的格式。\n\n```javascript\nfunction fun(){\n    var a = 1,\n        b = 3,\n        c = 5;\n\n    // do some thing\n}\n```\n\n## 判断相等\n\n判断相等的时候，请使用严格相等符号 ``===`` 而不是 ``==``\n\n## 分号的使用\n\n在每一个表达式结束的时候加上分号\n并不是所有的语句都是表达式，下面举例说明\n\n```javascript\n\nfunction fun(){\n\n} //函数声明，不是表达式，无需分号\n\n\nvar getName = function(){\n\n}; //函数表达式，请加上分号\n\n\nif(true){\n\n} //这也不是表达式，当然不用加分号\n\n```\n\n## 循环\n\n### for-in循环\n\n在使用for-in循环的时候，请注意两点\n\n1. 不要使用for-in循环遍历数组元素\n2. 在使用for-in遍历对象的时候，请判断属性是否来自继承\n\n```javascript\n\nvar obj = {x:1,y:2,z:3}\n\nfor(var e in obj){\n    if(!obj.hasOwnProperty(e)) continue;\n\n    // do something to e\n\n}\n\n```\n\n### 数组的遍历\n\n如果要对数组进行遍历，可以使用传统的 for 循环，或者es5提供的数组遍历方法。\n\n```javascript\n\n// 传统的 for 方法\n\nvar arr = [1,2,3,4,5];\n\nfor(var i = 0, e = arr[i]; i < arr.length; i++){\n\n    // do something to e\n\n}\n\n```\n\nes5的数组操作方法\n\n- forEach\n- every\n- map\n- filter\n- some\n- reduce\n\n使用这些方法的时候请注意[兼容性](http://caniuse.com/#search=forEach)\n\n## 引号的使用\n\n在javascript中使用单引号，而在html标签中使用双引号\n\n```javascript\nvar str = 'this is string';\n```\n\n```html\n<div class=\"footer\"> </div>\n```\n\n## 模块化\n\n目前使用的模块化的方式是两种，一种是模板模式，一种是 browserify.\n\n既然做了模块化，需要做到一个文件放一个模块。\n\n### 模板模式\n\n使用一个立即执行函数对每一段代码进行封装，避免变量暴露在全局\n\n```javascript\n\n/**\n * [description]\n * \n * @module [modulename]\n * @author sumight\n */\n\n(function($){\n    'use strict';\n\n    var Main = window.Main = {};\n        \n    /**\n     * 模块的默认配置\n     */\n    Main.defaultCfg = {\n\n    };\n\n    /**\n     * 模块初始化\n     * \n     * @param  {Object} cfg 用户配置\n     */\n    Main.init = function(cfg){\n        var self = this,\n            cfg = this._cfg = $.extend({}, self.defaultCfg, cfg);\n\n        // do something\n        \n    };\n\n    /**\n     * 初始化事件\n     */\n    Main.initEvent = function(){\n\n    };\n}(jQuery));\n\n```\n\n### browserify\n\n采用nodejs的模块化方式写前端代码。\n\n```javascript\n\n/**\n * [description]\n * \n * @module [modulename]\n * @author sumight\n */\n\n'use strict';\n\n/**\n * 模块依赖\n */\nvar $ = require(\"jQuery\"),\n    util = require(\"util\");\n\n/**\n * 导出模块\n * 如果模块需要暴露给html\n * 就这样写\n *  var Main = window.Main = exports;\n */\nvar Main = exports;\n\n/**\n * 模块的默认配置\n */\nMain.defaultCfg = {\n\n}\n\n/**\n * 模块初始化\n * \n * @param  {Object} cfg 用户配置\n */\nMain.init = function(cfg){\n    var self = this,\n        cfg = this._cfg = $.extend({}, self.defaultCfg, cfg);\n\n    // do something\n    \n};\n\n/**\n * 初始化事件\n */\nMain.initEvent = function(){\n\n};\n\n\n```\n","slug":"javascript代码规范","published":1,"updated":"2015-12-03T14:39:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwuo000gr1bhjikcrzqf"},{"title":"html注释规范","date":"2015-12-04T03:20:08.000Z","_content":"\n## 内容的注释\n\n显然不必给每个html模块都加上注释，给一些大的比较关键的html模块加上注释\n\n由于现在编辑器都有代码自动对齐和折叠的功能，注释不必结束，这样反而更加清晰\n\n每一行注释之前加一个空行\n\n\n```html\n\n<!-- 主体内容 -->\n<div class=\"content\">\n\n    <!-- 页面导航 -->\n    <nav>\n        <ul>\n            <li></li>\n            <li></li>\n        </ul>\n    </nav>\n</div>\n\n<!-- 页面页脚信息 -->\n<div class=\"footer\">\n\n</div>\n\n```\n\n\n## 脚本注释\n\n在脚本引入的时候用注释，来说明一段脚本的作用非常重要\n\n在引入一段新的脚本的时候，别人需要了解之前脚本的功能，判断新脚本的引入位置\n\n```html\n\n<!-- 库脚本 -->\n<script type=\"text/javascript\" src=\"jQuery.js\"></script>\n\n<!-- 统计代码 -->\n<script type=\"text/javascript\" src=\"ga-google.js\"></script>\n\n```","source":"_posts/html注释规范.md","raw":"title: html注释规范\ndate: 2015-12-04 11:20:08\ncategories:\n- 前端规范\n- 前端代码规范\n---\n\n## 内容的注释\n\n显然不必给每个html模块都加上注释，给一些大的比较关键的html模块加上注释\n\n由于现在编辑器都有代码自动对齐和折叠的功能，注释不必结束，这样反而更加清晰\n\n每一行注释之前加一个空行\n\n\n```html\n\n<!-- 主体内容 -->\n<div class=\"content\">\n\n    <!-- 页面导航 -->\n    <nav>\n        <ul>\n            <li></li>\n            <li></li>\n        </ul>\n    </nav>\n</div>\n\n<!-- 页面页脚信息 -->\n<div class=\"footer\">\n\n</div>\n\n```\n\n\n## 脚本注释\n\n在脚本引入的时候用注释，来说明一段脚本的作用非常重要\n\n在引入一段新的脚本的时候，别人需要了解之前脚本的功能，判断新脚本的引入位置\n\n```html\n\n<!-- 库脚本 -->\n<script type=\"text/javascript\" src=\"jQuery.js\"></script>\n\n<!-- 统计代码 -->\n<script type=\"text/javascript\" src=\"ga-google.js\"></script>\n\n```","slug":"html注释规范","published":1,"updated":"2015-12-04T06:50:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwus000jr1bhb7vkf41x"},{"title":"html代码规范","date":"2015-12-04T01:47:03.000Z","_content":"\n## 文档类型声明\n\n采用html5的文档类型声明。\n\n文档类型声明放在html文档的开头\n\n```html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n\n</body>\n</html>\n\n```\n\n必须添加 doctype ，否在在IE浏览器老版本浏览器下不会用正确的模式进行解析\n\n## 脚本引入\n\n### 脚本的引入位置\n\n脚本的下载和解析会阻塞DOM的解析。所以不要再文档的开头引入脚本。\n\n脚本放在 body 结束标签之前。\n\n并且按照脚本的执行顺序，添加 ``script`` 标签。\n\n```html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n\n<!-- 文档内容 -->\n\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\n<script type=\"text/javascript\" src=\"main.js\"></script>\n</body>\n</html>\n\n```\n\n不要在script标签中添加 asyc defer 属性，这样会打乱 js 的执行顺序，从而发送错误\n\n### 内联脚本\n\n只有在一种情况下使用内联脚本，就是在需要对页面进行用户配置的时候\n\n且尽可能只暴露一个入口用于配置\n\n```html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n\n<!-- 文档内容 -->\n\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\n<script type=\"text/javascript\" src=\"main.js\"></script>\n<script type=\"text/javascript\">\n    Main.init({\n        name:'1234'\n    });\n</script>\n</body>\n</html>\n\n```\n\n## 样式的引入\n\n### 内联样式\n\n不要使用内联样式\n\n```html\n\n<!-- 不要这样使用 -->\n<style type=\"text/css\">\n    .footer {\n        color:red;\n    }\n</style>\n\n```\n\n### 嵌入式样式\n\n不要使用嵌入式样式\n\n```html\n\n<!-- 不要这样使用 -->\n<div class=\"footer\" style=\"color:red\">\n    \n</div>\n\n```\n\n## id的使用\n\n尽量不要使用 id 作为css选择器\n\n只将 id 作为锚点使用\n\n## 引号\n\n在html中使用双引号，在js中使用单引号\n\n## 标签的闭合\n\n单标签不需要闭合\n\n```html\n\n<br>\n\n<hr>\n\n```","source":"_posts/html代码规范.md","raw":"title: html代码规范\ndate: 2015-12-04 09:47:03\ncategories:\n- 前端规范\n- 前端代码规范\n---\n\n## 文档类型声明\n\n采用html5的文档类型声明。\n\n文档类型声明放在html文档的开头\n\n```html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n\n</body>\n</html>\n\n```\n\n必须添加 doctype ，否在在IE浏览器老版本浏览器下不会用正确的模式进行解析\n\n## 脚本引入\n\n### 脚本的引入位置\n\n脚本的下载和解析会阻塞DOM的解析。所以不要再文档的开头引入脚本。\n\n脚本放在 body 结束标签之前。\n\n并且按照脚本的执行顺序，添加 ``script`` 标签。\n\n```html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n\n<!-- 文档内容 -->\n\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\n<script type=\"text/javascript\" src=\"main.js\"></script>\n</body>\n</html>\n\n```\n\n不要在script标签中添加 asyc defer 属性，这样会打乱 js 的执行顺序，从而发送错误\n\n### 内联脚本\n\n只有在一种情况下使用内联脚本，就是在需要对页面进行用户配置的时候\n\n且尽可能只暴露一个入口用于配置\n\n```html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n\n<!-- 文档内容 -->\n\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\n<script type=\"text/javascript\" src=\"main.js\"></script>\n<script type=\"text/javascript\">\n    Main.init({\n        name:'1234'\n    });\n</script>\n</body>\n</html>\n\n```\n\n## 样式的引入\n\n### 内联样式\n\n不要使用内联样式\n\n```html\n\n<!-- 不要这样使用 -->\n<style type=\"text/css\">\n    .footer {\n        color:red;\n    }\n</style>\n\n```\n\n### 嵌入式样式\n\n不要使用嵌入式样式\n\n```html\n\n<!-- 不要这样使用 -->\n<div class=\"footer\" style=\"color:red\">\n    \n</div>\n\n```\n\n## id的使用\n\n尽量不要使用 id 作为css选择器\n\n只将 id 作为锚点使用\n\n## 引号\n\n在html中使用双引号，在js中使用单引号\n\n## 标签的闭合\n\n单标签不需要闭合\n\n```html\n\n<br>\n\n<hr>\n\n```","slug":"html代码规范","published":1,"updated":"2015-12-04T03:25:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwuv000mr1bhig7ryy64"},{"title":"辨析 Sass 中的 Map 和 List","date":"2015-10-21T02:34:12.000Z","_content":"\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","source":"_posts/c.md","raw":"title: 辨析 Sass 中的 Map 和 List\ndate: 2015-10-21 10:34:12\ntags:\n- abc\ncategories:\n- other\n---\n\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","slug":"c","published":1,"updated":"2015-12-03T01:25:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwuz000pr1bhs2489a5f"},{"title":"jquery","date":"2015-10-21T02:34:12.000Z","_content":"\n```json\n{\n    \"title\":\"asdf\"\n}\n```\n\n\n```java\nclass ab {\n    a:1,\n    c:2\n}\n```\n\n```javascript\n$(\"#box\").goto();\nfunction asdl(sdf){\n    console.log();\n    document.getElementById();\n}\n```\n\n","source":"_posts/b.md","raw":"title: jquery\ndate: 2015-10-21 10:34:12\ntags:\n- abc\ncategories:\n- other\n- theother\n---\n\n```json\n{\n    \"title\":\"asdf\"\n}\n```\n\n\n```java\nclass ab {\n    a:1,\n    c:2\n}\n```\n\n```javascript\n$(\"#box\").goto();\nfunction asdl(sdf){\n    console.log();\n    document.getElementById();\n}\n```\n\n","slug":"b","published":1,"updated":"2015-12-03T01:25:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwv1000ur1bh15pm3fpf"},{"title":"arrow-left","date":"2015-11-23T12:29:38.000Z","_content":"\n左箭头\n\n```less\n.arrow-left(@width, @height, @border)\n```\n\n## 参数\n\n| 参数名 | 含义 |\n|:-----:|:----:|\n| @width |箭头的宽度|\n| @height |箭头的高度|\n| @border |箭头线条的宽度|\n\n\n## demo\n\n### 代码\n\n```less\n.add-btn {\n    margin-top: -15px;\n    top: 50%;\n    right: 45px;\n    .ico-add(30px, gray, white);\n    position: absolute;\n}\n```\n\n### 效果\n\n\n<i class=\"demo\"></i>\n\n\n<style type=\"text/css\">\n.demo {\n  margin: 10px 0;\n  width: 0.88888889rem;\n  height: 1.77777778rem;\n  position: relative;\n  display: inline-block;\n  -webkit-transform-origin: 50% 0%;\n  -webkit-transform: scaleY(1.25);\n  transform-origin: 50% 0%;\n  transform: scaleY(1.25);\n  position: relative;\n  top: 50%;\n  left: 2.5rem;\n}\n.demo:after {\n  content: '';\n  display: block;\n  box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  width: 1.25707872rem;\n  height: 1.25707872rem;\n  border-left: 2px solid #999999;\n  border-bottom: 2px solid #999999;\n  position: absolute;\n  top: 0.26034953rem;\n  left: 0.26034953rem;\n  -webkit-transform: rotate(45deg);\n  -webkit-transform-origin: 50% 50%;\n  transform: rotate(45deg);\n  transform-origin: 50% 50%;\n}\n</style>\n\n\n## 源代码\n```less\n.arrow-left(@width, @height, @border) {\n    width: @width;\n    height: 2*@width;\n    position: relative;\n    display: inline-block;\n    &:after {\n        content: '';\n        display: block;\n        box-sizing: border-box;\n        -webkit-box-sizing: border-box;\n        width: @width*sqrt(2);\n        height: @width*sqrt(2);\n        border-left: @border;\n        border-bottom: @border;\n        position: absolute;\n        top: (@width*2 - @width*sqrt(2))/2;\n        left: (@width*2 - @width*sqrt(2))/2;\n        \n        -webkit-transform: rotate(45deg);\n        -webkit-transform-origin: 50% 50%;\n        transform: rotate(45deg);\n        transform-origin: 50% 50%;\n        // border-top-left-radius: 3px;\n        // border-bottom-right-radius: 3px;\n    }\n    -webkit-transform-origin:50% 0%;\n    -webkit-transform:scaleY(unit(@height/(2*@width)));\n    transform-origin:50% 0%;\n    transform:scaleY(unit(@height/(2*@width)));\n}\n```","source":"_posts/arrow-left.md","raw":"title: arrow-left\ndate: 2015-11-23 20:29:38\ncategories:\n- less图标库\n---\n\n左箭头\n\n```less\n.arrow-left(@width, @height, @border)\n```\n\n## 参数\n\n| 参数名 | 含义 |\n|:-----:|:----:|\n| @width |箭头的宽度|\n| @height |箭头的高度|\n| @border |箭头线条的宽度|\n\n\n## demo\n\n### 代码\n\n```less\n.add-btn {\n    margin-top: -15px;\n    top: 50%;\n    right: 45px;\n    .ico-add(30px, gray, white);\n    position: absolute;\n}\n```\n\n### 效果\n\n\n<i class=\"demo\"></i>\n\n\n<style type=\"text/css\">\n.demo {\n  margin: 10px 0;\n  width: 0.88888889rem;\n  height: 1.77777778rem;\n  position: relative;\n  display: inline-block;\n  -webkit-transform-origin: 50% 0%;\n  -webkit-transform: scaleY(1.25);\n  transform-origin: 50% 0%;\n  transform: scaleY(1.25);\n  position: relative;\n  top: 50%;\n  left: 2.5rem;\n}\n.demo:after {\n  content: '';\n  display: block;\n  box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  width: 1.25707872rem;\n  height: 1.25707872rem;\n  border-left: 2px solid #999999;\n  border-bottom: 2px solid #999999;\n  position: absolute;\n  top: 0.26034953rem;\n  left: 0.26034953rem;\n  -webkit-transform: rotate(45deg);\n  -webkit-transform-origin: 50% 50%;\n  transform: rotate(45deg);\n  transform-origin: 50% 50%;\n}\n</style>\n\n\n## 源代码\n```less\n.arrow-left(@width, @height, @border) {\n    width: @width;\n    height: 2*@width;\n    position: relative;\n    display: inline-block;\n    &:after {\n        content: '';\n        display: block;\n        box-sizing: border-box;\n        -webkit-box-sizing: border-box;\n        width: @width*sqrt(2);\n        height: @width*sqrt(2);\n        border-left: @border;\n        border-bottom: @border;\n        position: absolute;\n        top: (@width*2 - @width*sqrt(2))/2;\n        left: (@width*2 - @width*sqrt(2))/2;\n        \n        -webkit-transform: rotate(45deg);\n        -webkit-transform-origin: 50% 50%;\n        transform: rotate(45deg);\n        transform-origin: 50% 50%;\n        // border-top-left-radius: 3px;\n        // border-bottom-right-radius: 3px;\n    }\n    -webkit-transform-origin:50% 0%;\n    -webkit-transform:scaleY(unit(@height/(2*@width)));\n    transform-origin:50% 0%;\n    transform:scaleY(unit(@height/(2*@width)));\n}\n```","slug":"arrow-left","published":1,"updated":"2015-11-23T12:44:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwv4000zr1bh38fdj518"},{"title":"辨析 Sass 中的 Map 和 List","date":"2015-10-21T02:34:12.000Z","_content":"\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","source":"_posts/a.md","raw":"title: 辨析 Sass 中的 Map 和 List\ndate: 2015-10-21 10:34:12\ntags:\n- abc\ncategories:\n---\n\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","slug":"a","published":1,"updated":"2015-11-23T14:45:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cihvgpwv90011r1bh56194lzg"}],"PostAsset":[],"PostCategory":[{"post_id":"cihvgpwug0006r1bhlrehtk0y","category_id":"cihvgpwuh0007r1bhaakhtw0p","_id":"cihvgpwuh0008r1bhfydee3ch"},{"post_id":"cihvgpwui0009r1bhckyfki2m","category_id":"cihvgpwuh0007r1bhaakhtw0p","_id":"cihvgpwuk000ar1bhd07qlbn9"},{"post_id":"cihvgpwul000br1bhhglu502q","category_id":"cihvgpwum000cr1bh3sek34kl","_id":"cihvgpwun000er1bhcqkjk3e9"},{"post_id":"cihvgpwul000br1bhhglu502q","category_id":"cihvgpwum000dr1bh3eraomao","_id":"cihvgpwun000fr1bhh3ue0byi"},{"post_id":"cihvgpwuo000gr1bhjikcrzqf","category_id":"cihvgpwum000cr1bh3sek34kl","_id":"cihvgpwup000hr1bhqhnv7uvj"},{"post_id":"cihvgpwuo000gr1bhjikcrzqf","category_id":"cihvgpwum000dr1bh3eraomao","_id":"cihvgpwup000ir1bhi213015u"},{"post_id":"cihvgpwus000jr1bhb7vkf41x","category_id":"cihvgpwum000cr1bh3sek34kl","_id":"cihvgpwut000kr1bht5mh90v5"},{"post_id":"cihvgpwus000jr1bhb7vkf41x","category_id":"cihvgpwum000dr1bh3eraomao","_id":"cihvgpwut000lr1bhgqyheq9u"},{"post_id":"cihvgpwuv000mr1bhig7ryy64","category_id":"cihvgpwum000cr1bh3sek34kl","_id":"cihvgpwux000nr1bhr3p85sbd"},{"post_id":"cihvgpwuv000mr1bhig7ryy64","category_id":"cihvgpwum000dr1bh3eraomao","_id":"cihvgpwux000or1bhc94urnz6"},{"post_id":"cihvgpwuz000pr1bhs2489a5f","category_id":"cihvgpwuz000qr1bhi551scay","_id":"cihvgpwv0000tr1bh792u780p"},{"post_id":"cihvgpwv1000ur1bh15pm3fpf","category_id":"cihvgpwuz000qr1bhi551scay","_id":"cihvgpwv3000xr1bh83bshswx"},{"post_id":"cihvgpwv1000ur1bh15pm3fpf","category_id":"cihvgpwv3000vr1bh1vmpbpod","_id":"cihvgpwv3000yr1bhgqiscck5"},{"post_id":"cihvgpwv4000zr1bh38fdj518","category_id":"cihvgpwuh0007r1bhaakhtw0p","_id":"cihvgpwv60010r1bh31kjtys0"},{"post_id":"cihvgpwu80002r1bh8qj8rft7","category_id":"cihvgpwua0003r1bhliwwxb0t","_id":"cihvgtll90016r1bhctil2msa"}],"PostTag":[{"post_id":"cihvgpwuz000pr1bhs2489a5f","tag_id":"cihvgpwv0000rr1bhs0qx0ve9","_id":"cihvgpwv0000sr1bhpks6lpg3"},{"post_id":"cihvgpwv1000ur1bh15pm3fpf","tag_id":"cihvgpwv0000rr1bhs0qx0ve9","_id":"cihvgpwv3000wr1bhdipui4dl"},{"post_id":"cihvgpwv90011r1bh56194lzg","tag_id":"cihvgpwv0000rr1bhs0qx0ve9","_id":"cihvgpwva0012r1bh7idw45l1"}],"Tag":[{"name":"abc","_id":"cihvgpwv0000rr1bhs0qx0ve9"}]}}